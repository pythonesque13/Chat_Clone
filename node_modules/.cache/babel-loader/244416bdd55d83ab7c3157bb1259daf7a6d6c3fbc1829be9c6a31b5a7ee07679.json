{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.partialParse = void 0;\nconst tokenize = input => {\n    let current = 0;\n    let tokens = [];\n    while (current < input.length) {\n      let char = input[current];\n      if (char === '\\\\') {\n        current++;\n        continue;\n      }\n      if (char === '{') {\n        tokens.push({\n          type: 'brace',\n          value: '{'\n        });\n        current++;\n        continue;\n      }\n      if (char === '}') {\n        tokens.push({\n          type: 'brace',\n          value: '}'\n        });\n        current++;\n        continue;\n      }\n      if (char === '[') {\n        tokens.push({\n          type: 'paren',\n          value: '['\n        });\n        current++;\n        continue;\n      }\n      if (char === ']') {\n        tokens.push({\n          type: 'paren',\n          value: ']'\n        });\n        current++;\n        continue;\n      }\n      if (char === ':') {\n        tokens.push({\n          type: 'separator',\n          value: ':'\n        });\n        current++;\n        continue;\n      }\n      if (char === ',') {\n        tokens.push({\n          type: 'delimiter',\n          value: ','\n        });\n        current++;\n        continue;\n      }\n      if (char === '\"') {\n        let value = '';\n        let danglingQuote = false;\n        char = input[++current];\n        while (char !== '\"') {\n          if (current === input.length) {\n            danglingQuote = true;\n            break;\n          }\n          if (char === '\\\\') {\n            current++;\n            if (current === input.length) {\n              danglingQuote = true;\n              break;\n            }\n            value += char + input[current];\n            char = input[++current];\n          } else {\n            value += char;\n            char = input[++current];\n          }\n        }\n        char = input[++current];\n        if (!danglingQuote) {\n          tokens.push({\n            type: 'string',\n            value\n          });\n        }\n        continue;\n      }\n      let WHITESPACE = /\\s/;\n      if (char && WHITESPACE.test(char)) {\n        current++;\n        continue;\n      }\n      let NUMBERS = /[0-9]/;\n      if (char && NUMBERS.test(char) || char === '-' || char === '.') {\n        let value = '';\n        if (char === '-') {\n          value += char;\n          char = input[++current];\n        }\n        while (char && NUMBERS.test(char) || char === '.') {\n          value += char;\n          char = input[++current];\n        }\n        tokens.push({\n          type: 'number',\n          value\n        });\n        continue;\n      }\n      let LETTERS = /[a-z]/i;\n      if (char && LETTERS.test(char)) {\n        let value = '';\n        while (char && LETTERS.test(char)) {\n          if (current === input.length) {\n            break;\n          }\n          value += char;\n          char = input[++current];\n        }\n        if (value == 'true' || value == 'false' || value === 'null') {\n          tokens.push({\n            type: 'name',\n            value\n          });\n        } else {\n          // unknown token, e.g. `nul` which isn't quite `null`\n          current++;\n          continue;\n        }\n        continue;\n      }\n      current++;\n    }\n    return tokens;\n  },\n  strip = tokens => {\n    if (tokens.length === 0) {\n      return tokens;\n    }\n    let lastToken = tokens[tokens.length - 1];\n    switch (lastToken.type) {\n      case 'separator':\n        tokens = tokens.slice(0, tokens.length - 1);\n        return strip(tokens);\n        break;\n      case 'number':\n        let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];\n        if (lastCharacterOfLastToken === '.' || lastCharacterOfLastToken === '-') {\n          tokens = tokens.slice(0, tokens.length - 1);\n          return strip(tokens);\n        }\n      case 'string':\n        let tokenBeforeTheLastToken = tokens[tokens.length - 2];\n        if (tokenBeforeTheLastToken?.type === 'delimiter') {\n          tokens = tokens.slice(0, tokens.length - 1);\n          return strip(tokens);\n        } else if (tokenBeforeTheLastToken?.type === 'brace' && tokenBeforeTheLastToken.value === '{') {\n          tokens = tokens.slice(0, tokens.length - 1);\n          return strip(tokens);\n        }\n        break;\n      case 'delimiter':\n        tokens = tokens.slice(0, tokens.length - 1);\n        return strip(tokens);\n        break;\n    }\n    return tokens;\n  },\n  unstrip = tokens => {\n    let tail = [];\n    tokens.map(token => {\n      if (token.type === 'brace') {\n        if (token.value === '{') {\n          tail.push('}');\n        } else {\n          tail.splice(tail.lastIndexOf('}'), 1);\n        }\n      }\n      if (token.type === 'paren') {\n        if (token.value === '[') {\n          tail.push(']');\n        } else {\n          tail.splice(tail.lastIndexOf(']'), 1);\n        }\n      }\n    });\n    if (tail.length > 0) {\n      tail.reverse().map(item => {\n        if (item === '}') {\n          tokens.push({\n            type: 'brace',\n            value: '}'\n          });\n        } else if (item === ']') {\n          tokens.push({\n            type: 'paren',\n            value: ']'\n          });\n        }\n      });\n    }\n    return tokens;\n  },\n  generate = tokens => {\n    let output = '';\n    tokens.map(token => {\n      switch (token.type) {\n        case 'string':\n          output += '\"' + token.value + '\"';\n          break;\n        default:\n          output += token.value;\n          break;\n      }\n    });\n    return output;\n  },\n  partialParse = input => JSON.parse(generate(unstrip(strip(tokenize(input)))));\nexports.partialParse = partialParse;","map":{"version":3,"names":["tokenize","input","current","tokens","length","char","push","type","value","danglingQuote","WHITESPACE","test","NUMBERS","LETTERS","strip","lastToken","slice","lastCharacterOfLastToken","tokenBeforeTheLastToken","unstrip","tail","map","token","splice","lastIndexOf","reverse","item","generate","output","partialParse","JSON","parse","exports"],"sources":["/home/martin/Documents/codes/Prog_Web/Project_React/clone/node_modules/openai/src/_vendor/partial-json-parser/parser.ts"],"sourcesContent":["type Token = {\n  type: string;\n  value: string;\n};\n\nconst tokenize = (input: string): Token[] => {\n    let current = 0;\n    let tokens: Token[] = [];\n\n    while (current < input.length) {\n      let char = input[current];\n\n      if (char === '\\\\') {\n        current++;\n        continue;\n      }\n\n      if (char === '{') {\n        tokens.push({\n          type: 'brace',\n          value: '{',\n        });\n\n        current++;\n        continue;\n      }\n\n      if (char === '}') {\n        tokens.push({\n          type: 'brace',\n          value: '}',\n        });\n\n        current++;\n        continue;\n      }\n\n      if (char === '[') {\n        tokens.push({\n          type: 'paren',\n          value: '[',\n        });\n\n        current++;\n        continue;\n      }\n\n      if (char === ']') {\n        tokens.push({\n          type: 'paren',\n          value: ']',\n        });\n\n        current++;\n        continue;\n      }\n\n      if (char === ':') {\n        tokens.push({\n          type: 'separator',\n          value: ':',\n        });\n\n        current++;\n        continue;\n      }\n\n      if (char === ',') {\n        tokens.push({\n          type: 'delimiter',\n          value: ',',\n        });\n\n        current++;\n        continue;\n      }\n\n      if (char === '\"') {\n        let value = '';\n        let danglingQuote = false;\n\n        char = input[++current];\n\n        while (char !== '\"') {\n          if (current === input.length) {\n            danglingQuote = true;\n            break;\n          }\n\n          if (char === '\\\\') {\n            current++;\n            if (current === input.length) {\n              danglingQuote = true;\n              break;\n            }\n            value += char + input[current];\n            char = input[++current];\n          } else {\n            value += char;\n            char = input[++current];\n          }\n        }\n\n        char = input[++current];\n\n        if (!danglingQuote) {\n          tokens.push({\n            type: 'string',\n            value,\n          });\n        }\n        continue;\n      }\n\n      let WHITESPACE = /\\s/;\n      if (char && WHITESPACE.test(char)) {\n        current++;\n        continue;\n      }\n\n      let NUMBERS = /[0-9]/;\n      if ((char && NUMBERS.test(char)) || char === '-' || char === '.') {\n        let value = '';\n\n        if (char === '-') {\n          value += char;\n          char = input[++current];\n        }\n\n        while ((char && NUMBERS.test(char)) || char === '.') {\n          value += char;\n          char = input[++current];\n        }\n\n        tokens.push({\n          type: 'number',\n          value,\n        });\n        continue;\n      }\n\n      let LETTERS = /[a-z]/i;\n      if (char && LETTERS.test(char)) {\n        let value = '';\n\n        while (char && LETTERS.test(char)) {\n          if (current === input.length) {\n            break;\n          }\n          value += char;\n          char = input[++current];\n        }\n\n        if (value == 'true' || value == 'false' || value === 'null') {\n          tokens.push({\n            type: 'name',\n            value,\n          });\n        } else {\n          // unknown token, e.g. `nul` which isn't quite `null`\n          current++;\n          continue;\n        }\n        continue;\n      }\n\n      current++;\n    }\n\n    return tokens;\n  },\n  strip = (tokens: Token[]): Token[] => {\n    if (tokens.length === 0) {\n      return tokens;\n    }\n\n    let lastToken = tokens[tokens.length - 1]!;\n\n    switch (lastToken.type) {\n      case 'separator':\n        tokens = tokens.slice(0, tokens.length - 1);\n        return strip(tokens);\n        break;\n      case 'number':\n        let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];\n        if (lastCharacterOfLastToken === '.' || lastCharacterOfLastToken === '-') {\n          tokens = tokens.slice(0, tokens.length - 1);\n          return strip(tokens);\n        }\n      case 'string':\n        let tokenBeforeTheLastToken = tokens[tokens.length - 2];\n        if (tokenBeforeTheLastToken?.type === 'delimiter') {\n          tokens = tokens.slice(0, tokens.length - 1);\n          return strip(tokens);\n        } else if (tokenBeforeTheLastToken?.type === 'brace' && tokenBeforeTheLastToken.value === '{') {\n          tokens = tokens.slice(0, tokens.length - 1);\n          return strip(tokens);\n        }\n        break;\n      case 'delimiter':\n        tokens = tokens.slice(0, tokens.length - 1);\n        return strip(tokens);\n        break;\n    }\n\n    return tokens;\n  },\n  unstrip = (tokens: Token[]): Token[] => {\n    let tail: string[] = [];\n\n    tokens.map((token) => {\n      if (token.type === 'brace') {\n        if (token.value === '{') {\n          tail.push('}');\n        } else {\n          tail.splice(tail.lastIndexOf('}'), 1);\n        }\n      }\n      if (token.type === 'paren') {\n        if (token.value === '[') {\n          tail.push(']');\n        } else {\n          tail.splice(tail.lastIndexOf(']'), 1);\n        }\n      }\n    });\n\n    if (tail.length > 0) {\n      tail.reverse().map((item) => {\n        if (item === '}') {\n          tokens.push({\n            type: 'brace',\n            value: '}',\n          });\n        } else if (item === ']') {\n          tokens.push({\n            type: 'paren',\n            value: ']',\n          });\n        }\n      });\n    }\n\n    return tokens;\n  },\n  generate = (tokens: Token[]): string => {\n    let output = '';\n\n    tokens.map((token) => {\n      switch (token.type) {\n        case 'string':\n          output += '\"' + token.value + '\"';\n          break;\n        default:\n          output += token.value;\n          break;\n      }\n    });\n\n    return output;\n  },\n  partialParse = (input: string): unknown => JSON.parse(generate(unstrip(strip(tokenize(input)))));\n\nexport { partialParse };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}